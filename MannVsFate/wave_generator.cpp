#include "wave_generator.h"
#include "rand_util.h"
#include "random_name_generator.h"
#include <unordered_set>
#include <sstream>
#include <algorithm>
#include <iostream>

void wave_generator::set_map_name(const std::string& in)
{
	map_name = in;
}

void wave_generator::set_mission_name(const std::string& in)
{
	mission_name = in;
}

void wave_generator::set_starting_currency(int in)
{
	starting_currency = in;
}

void wave_generator::set_waves(int in)
{
	waves = in;
}

void wave_generator::set_respawn_wave_time(int in)
{
	respawn_wave_time = in;
}

void wave_generator::set_event_popfile(int in)
{
	event_popfile = in;
}

void wave_generator::set_fixed_respawn_wave_time(bool in)
{
	fixed_respawn_wave_time = in;
}

void wave_generator::set_add_sentry_buster_when_damage_dealt_exceeds(int in)
{
	add_sentry_buster_when_damage_dealt_exceeds = in;
}

void wave_generator::set_add_sentry_buster_when_kill_count_exceeds(int in)
{
	add_sentry_buster_when_kill_count_exceeds = in;
}

void wave_generator::set_can_bots_attack_while_in_spawn_room(int in)
{
	can_bots_attack_while_in_spawn_room = in;
}

void wave_generator::set_sentry_buster_cooldown(float in)
{
	sentry_buster_cooldown = in;
}

void wave_generator::set_players(int in)
{
	players = in;
}

void wave_generator::set_currency_per_wave(int in)
{
	currency_per_wave = in;
}

void wave_generator::set_max_time(int in)
{
	max_time = in;
}

void wave_generator::set_tank_chance(float in)
{
	tank_chance = in;
}

void wave_generator::set_max_icons(int in)
{
	max_icons = in;
}

void wave_generator::set_max_wavespawns(int in)
{
	max_wavespawns = in;
}

void wave_generator::set_possible_classes(const std::vector<player_class>& classes)
{
	possible_classes = classes;
}

void wave_generator::generate_mission(int argc, char** argv)
{
	// Instantiate the random name generator.
	random_name_generator random_names("names/verbs.txt", "names/titles.txt", "names/adjectives.txt", "names/nouns.txt");

	std::stringstream filename;
	filename << map_name << '_' << players << "p_" << mission_name << ".pop";
	popfile.open(filename.str());
	if (!popfile)
	{
		const std::string exstr = "wave_generator::generate exception: Couldn't write to file \"" + filename.str() + "\".";
		throw std::exception(exstr.c_str());
	}

	// Generate a bit of nice info at the top of the mission file.
	write("// This mission file was randomly generated by Mann Vs Fate version " + version + '.');
	if (argc > 1)
	{
		write("// The following command line arguments were used:");
		popfile << "// ";
		for (int i = 1; i < argc; ++i)
		{
			popfile << argv[i] << ' ';
		}
		popfile << '\n';
	}
	write_blank();
	write("#base robot_giant.pop");
	write_blank();
	block_start("WaveSchedule");

	// WaveSchedule universal options.
	write("StartingCurrency", starting_currency);
	write("RespawnWaveTime", respawn_wave_time);
	if (event_popfile != 0)
	{
		write("EventPopfile", event_popfile);
	}
	if (fixed_respawn_wave_time)
	{
		write("FixedRespawnWaveTime", 1);
	}
	write("AddSentryBusterWhenDamageDealtExceeds", add_sentry_buster_when_damage_dealt_exceeds);
	write("AddSentryBusterWhenKillCountExceeds", add_sentry_buster_when_kill_count_exceeds);
	if (can_bots_attack_while_in_spawn_room == 0)
	{
		write("CanBotsAttackWhileInSpawnRoom", "no");
	}
	else
	{
		write("CanBotsAttackWhileInSpawnRoom", "yes");
	}
	write_blank();
	// Sentry Buster Mission.
	block_start("Mission");
	write("Objective", "DestroySentries");
	write("InitialCooldown", 5);
	write("Where", "spawnbot");
	write("BeginAtWave", 1);
	write("RunForThisManyWaves", waves);
	write("CooldownTime", sentry_buster_cooldown);
	block_start("TFBot");
	write("Template", "T_TFBot_SentryBuster");
	block_end(); // TFBot
	block_end(); // Mission

	// How much currency the players currently have.
	int current_currency = starting_currency;

	// Generate the actual waves!
	while (current_wave < waves)
	{
		++current_wave;

		std::cout << "Generating wave " << current_wave << '/' << waves << '.' << std::endl;

		write_indents();
		popfile << "// WAVE " << current_wave <<
			" ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n";
		block_start("Wave");
		block_start("StartWaveOutput");
		write("Target", "wave_start_relay");
		write("Action", "Trigger");
		block_end(); // StartWaveOutput
		block_start("DoneOutput");
		write("Target", "wave_finished_relay");
		write("Action", "Trigger");
		block_end(); // DoneOutPut

		std::cout << "Generated wave header, starting actual wavespawn generation..." << std::endl;

		// The actual WaveSpawn generation starts here!

		// Our current position in time in the wave as we walk through the wave.
		// We will use this to determine each WaveSpawn's WaitBeforeStarting value.
		int t = 0;
		// A vector of all wavespawns that have been instantiated so far.
		std::vector<wavespawn> wavespawns;
		// An unordered set of all of the icons that are part of the wave so far.
		std::unordered_set<std::string> class_icons;
		// How much pressure is currently being placed on the theoretical players of the mission.
		// More pressure means the players are having a harder time.
		// We're assuming our players are disposing of the robot baddies over time,
		// so this pressure value should decay over time if left unattended.
		// If there's too much pressure, we should ease up on the players.
		// If there's too little pressure, we should go harder on the players.
		float pressure = 0.0f;

		// The more currency the players have, the more damage they'll be able to deal.
		// The more damage the players can deal, the quicker they'll be able to dispose of the enemies.
		// The number of players also affects how quickly the robots can be dealt with.
		// Let's have the pressure decay based on this quantity of currency multiplied by the number of players.
		// This decay rate is measured per second.
		// Since this decay rate essentially calculates how powerful and capable the RED team is,
		// it is also used to calculate how powerful the robots should be.
		float pressure_decay_rate = (current_currency * currency_pressure_multiplier + base_pressure_decay_rate) * players * pressure_decay_rate_multiplier;

		std::cout << "The pressure decay rate is " << pressure_decay_rate << '.' << std::endl;

		/*
		int tanks = 0;
		while (rand_chance(tank_chance) && tanks < 137)
		{
			++tanks;
			if (tank_chance >= 1.0f)
			{
				break;
			}
		}
		if (tanks != 0)
		{
			class_icons.emplace("tank");

			float absolute_end_time = max_time * 0.8f;
			float first_tank_time = rand_float(0, absolute_end_time * 0.8f);
			float remaining_time = absolute_end_time - first_tank_time;
			float time_between_spawns = remaining_time / (tanks + 1);
			float speed = rand_float(10, 100);
			int health = static_cast<int>(ceil((rand_float(5, 12) * 100000 / speed) / 1000) * 1000);
			
			wavespawn ws;
			std::stringstream wsname;
			wsname << "\"wave" << current_wave << '_' << wavespawns.size() + 1 << '\"';
			ws.name = wsname.str();
			ws.total_count = tanks;
			ws.wait_before_starting = first_tank_time;
			ws.wait_between_spawns = time_between_spawns;
			ws.time_until_next_spawn = ws.wait_before_starting;
			ws.spawns_remaining = ws.total_count;
			ws.effective_pressure = static_cast<float>(health);
			ws.time_to_kill = ws.effective_pressure / pressure_decay_rate;
			ws.type_of_spawned = wavespawn::type::tank;
			ws.tnk.speed = speed;
			ws.tnk.health = health;
			wavespawns.emplace_back(ws);
		}

		std::cout << "Generated " << tanks << " tank(s)." << std::endl;
		*/

		/*
		// Make sure that all Heavy deflectors in the wave are either giant or not giant.
		bool is_deflector_giant;
		if (rand_chance(0.5f))
		{
			is_deflector_giant = true;
		}
		else
		{
			is_deflector_giant = false;
		}
		*/

		// This loop generates all of the TFBot WaveSpawns.
		while (t < max_time && wavespawns.size() < max_wavespawns && class_icons.size() < max_icons)
		{
			// The rate at which the pressure is decaying when all active wavespawns are taken into consideration.
			/*
			float effective_pressure_decay_rate;

			calculate_effective_pressure_decay_rate(pressure_decay_rate, effective_pressure_decay_rate, wavespawns, t);

			while (effective_pressure_decay_rate > 0 && t < max_time && wavespawns.size() < max_wavespawns && class_icons.size() < max_icons)
			{
				std::cout << "Effective pressure decay rate > 0." << std::endl;
				*/

			std::cout << "Generating new wavespawn at t = " << t << '.' << std::endl;

			// Let's generate a random TFBot.
			tfbot bot;

			// This is the multiplier for calculating the bot's threat level by multiplying its health.
			// The multiplier is adjusted based on a variety of factors.
			// A higher multiplier means the bot is harder to deal with.
			float bot_pressure = 1.0f;

			// Give the bot a random name!
			bot.name = random_names.get_random_name();
			// Randomize the bot's class.
			bot.cl = possible_classes.at(rand_int(0, possible_classes.size()));
			player_class item_class = bot.cl;

			// Choose a weapon restriction.
			//if (bot.cl != player_class::engineer)
			//{
			if (rand_chance(0.3f))
			{
				std::vector<std::string> restrictions;
				if (bot.cl != player_class::spy)
				{
					restrictions.emplace_back("PrimaryOnly");
				}
				restrictions.emplace_back("SecondaryOnly");
				restrictions.emplace_back("MeleeOnly");
				bot.weapon_restrictions = restrictions.at(rand_int(0, restrictions.size()));
			}
			//}

			/*
			if (rand_chance(0.1f))
			{
				item_class = possible_classes.at(rand_int(0, possible_classes.size()));
			}
			*/

			// Set the bot's health based on its class.
			bot.health = get_class_default_health(bot.cl);

			// Get the bot's class icon.
			bot.class_icon = get_class_icon(bot.cl);
			const std::string item_class_icon = get_class_icon(item_class);

			// Give the bot items here, prior to any chance of becoming a giant!
			list_reader item_reader;
			const std::string initial_path = "items/" + item_class_icon + '/';
			const std::string initial_path_bot = "items/" + bot.class_icon + '/';

			const std::string file_secondary = initial_path + "secondary.txt";
			const std::string file_melee = initial_path + "melee.txt";
			item_reader.load(file_secondary);
			item_reader.load(file_melee);
			const std::string secondary = item_reader.get_random(file_secondary);
			const std::string melee = item_reader.get_random(file_melee);
			bot.items.emplace_back(secondary);
			bot.items.emplace_back(melee);

			std::string primary;

			if (bot.cl == player_class::spy)
			{
				// Spies have some extra weapon slots.

				const std::string file_pda2 = initial_path_bot + "pda2.txt";
				item_reader.load(file_pda2);
				const std::string pda2 = item_reader.get_random(file_pda2);
				bot.items.emplace_back(pda2);

				const std::string file_building = initial_path_bot + "building.txt";
				item_reader.load(file_building);
				const std::string building = item_reader.get_random(file_building);
				bot.items.emplace_back(building);
			}
			else if (item_class != player_class::spy)
			{
				// Spies do not have primary weapons.

				const std::string file_primary = initial_path + "primary.txt";
				item_reader.load(file_primary);
				primary = item_reader.get_random(file_primary);
				bot.items.emplace_back(primary);
			}
			else
			{
				const std::string file_primary = initial_path_bot + "primary.txt";
				item_reader.load(file_primary);
				primary = item_reader.get_random(file_primary);
				bot.items.emplace_back(primary);
			}

			float move_speed_bonus = 1.0f;
			float damage_bonus = 1.0f;

			// The multiplier on most random chance calls. A higher value here means more of the random chances will likely return true.
			float chanceMult = 1.0f;
			// Whether the bot is a giant.
			bool isGiant = false;
			// Whether the bot is a boss (i.e. ultra-powerful giant).
			bool isBoss = false;
			// Whether the bot cannot become a boss.
			bool permaSmall = false;
			// Whether the bot has the AlwaysCrit attribute.
			bool isAlwaysCrit = false;
			// Whether the bot has the AlwaysFireWeapon attribute.
			bool isAlwaysFireWeapon = false;

			if (!isAlwaysCrit && rand_chance(0.1f))
			{
				bot.attributes.emplace_back("AlwaysCrit");
				bot_pressure *= 4.5f;
				isAlwaysCrit = true;
			}

			// If the bot is a Heavy, possibly set deflector properties.
			if (bot.cl == player_class::heavyweapons)
			{
				if (rand_chance(0.1f))
				{
					bot.character_attributes.emplace_back("attack projectiles", 1);
					/*
					if (is_deflector_giant)
					{
						make_bot_into_giant(bot, isGiant, move_speed_bonus, chanceMult, bot_pressure, isBoss, isAlwaysCrit);
					}
					else
					{
						permaSmall = true;
					}
					*/
					bot.class_icon = "heavy_deflector";
					bot_pressure *= 2.5f;
				}
			}

			// Choose a class icon based on the weapons chosen.
			switch (bot.cl)
			{
			case player_class::demoman:
				if (bot.weapon_restrictions == "MeleeOnly")
				{
					if (melee == "The Eyelander" ||
						melee == "The Scotsman's Skullcutter" ||
						melee == "The Horseless Headless Horseman's Headtaker" ||
						melee == "The Claidheamohmor" ||
						melee == "The Half-Zatoichi" ||
						melee == "The Persian Persuader" ||
						melee == "Festive Eyelander")
					{
						bot.class_icon = "demoknight";
					}
				}
				break;

			case player_class::heavyweapons:
				if (bot.weapon_restrictions == "MeleeOnly")
				{
					if (melee == "The Killing Gloves of Boxing")
					{
						bot.class_icon = "heavy_champ";
					}
					else if (melee == "Gloves of Running Urgently" ||
						melee == "Festive Gloves of Running Urgently")
					{
						bot.class_icon = "heavy_gru";
					}
					else if (melee == "The Holiday Punch")
					{
						bot.class_icon = "heavy_mittens";
						bot.attributes.emplace_back("AlwaysCrit");
						isAlwaysCrit = true;
					}
					else if (melee == "Fists of Steel")
					{
						bot.class_icon = "heavy_steelfist";
					}
				}
				else if (bot.weapon_restrictions == "SecondaryOnly")
				{
					if (secondary == "TF_WEAPON_SHOTGUN_PRIMARY" ||
						secondary == "The Family Business" ||
						secondary == "Festive Shotgun 2014" ||
						secondary == "Panic Attack Shotgun")
					{
						bot.class_icon = "heavy_shotgun";
					}
				}
				else if (bot.weapon_restrictions != "MeleeOnly")
				{
					if (primary == "The Huo Long Heatmaker")
					{
						bot.class_icon = "heavy_heater";
					}
				}
				break;

			case player_class::pyro:
				if (bot.weapon_restrictions == "SecondaryOnly")
				{
					if (secondary == "The Flare Gun" ||
						secondary == "The Scorch Shot" ||
						secondary == "Festive Flare Gun" ||
						secondary == "The Detonator" ||
						secondary == "The Manmelter")
					{
						bot.class_icon = "pyro_flare";
					}
				}
				break;

			case player_class::scout:
				if (bot.weapon_restrictions == "MeleeOnly")
				{
					if (melee == "TF_WEAPON_BAT" ||
						melee == "Festive Bat 2011")
					{
						bot.class_icon = "scout_bat";
					}
					else if (melee == "The Sandman")
					{
						bot.class_icon = "scout_stun";
					}
				}
				else
				{
					if (primary == "The Shortstop")
					{
						bot.class_icon = "scout_shortstop";
					}
				}
				if (secondary == "Bonk! Atomic Punch" || secondary == "Festive Bonk 2014")
				{
					bot.class_icon = "scout_bonk";
					bot.items.emplace_back("Bonk Helm");
					bot_pressure *= 2.5f;
				}
				break;

			case player_class::sniper:
				if (bot.weapon_restrictions == "SecondaryOnly")
				{
					bot.class_icon = "sniper_jarate";
				}
				else
				{
					if (primary == "The Huntsman" ||
						primary == "Festive Huntsman")
					{
						bot.class_icon = "sniper_bow";
					}
					else if (primary == "The Sydney Sleeper")
					{
						bot.class_icon = "sniper_sydneysleeper";
					}
				}
				break;

			case player_class::soldier:
				if (bot.weapon_restrictions != "MeleeOnly")
				{
					if (primary == "The Black Box" ||
						primary == "Festive Black Box")
					{
						bot.class_icon = "soldier_blackbox";
					}
					else if (primary == "The Liberty Launcher")
					{
						bot.class_icon = "soldier_libertylauncher";
					}
				}
				if (secondary == "The Battalion's Backup")
				{
					bot.class_icon = "soldier_backup";
				}
				else if (secondary == "The Buff Banner" ||
					secondary == "Festive Buff Banner")
				{
					bot.class_icon = "soldier_buff";
				}
				else if (secondary == "The Concheror")
				{
					bot.class_icon = "soldier_conch";
				}
			}

			if (rand_chance(0.05f))
			{
				float change = rand_float(0.5f, 3.0f);
				move_speed_bonus *= change;
				bot_pressure *= change;
			}

			if (bot.cl == player_class::engineer)
			{
				// Make it so that engineers cannot pick up the bomb.
				bot.character_attributes.emplace_back("cannot pick up intelligence", 1);
			}
			if (item_class == player_class::sniper)
			{
				if ((bot.weapon_restrictions == "" || bot.weapon_restrictions == "PrimaryOnly") && !isAlwaysFireWeapon &&
					bot.class_icon != "sniper_bow" && primary != "The Classic")
				{
					bot.attributes.emplace_back("AlwaysFireWeapon");
					isAlwaysFireWeapon = true;
				}
			}

			if (bot.cl == player_class::spy)
			{
				//chanceMult *= 3.0f;
				bot_pressure *= 1.2f;
			}

			// A bot has a chance to be a giant.
			if (!isGiant && !permaSmall && rand_chance(0.1f))
			{
				make_bot_into_giant(bot, isGiant, move_speed_bonus, chanceMult, bot_pressure, isBoss, isAlwaysCrit);
			}
			// Have a chance to tweak the health value.
			if ((isGiant && rand_chance(0.8f)) || rand_chance(0.5f))
			{
				bot.health *= rand_float(0.2f * chanceMult, 5.0f);
			}
			if (rand_chance(0.1f * chanceMult))
			{
				bot.attributes.emplace_back("Aggressive");
			}
			if (item_class == player_class::medic && rand_chance(0.5f * chanceMult))
			{
				bot.attributes.emplace_back("SpawnWithFullCharge");
				bot_pressure *= 2.0f;
			}
			if (rand_chance(0.1f * chanceMult) && !isAlwaysFireWeapon)
			{
				if (rand_chance(0.4f))
				{
					bot.attributes.emplace_back("HoldFireUntilFullReload");
					bot_pressure *= 1.1f;
				}
				else
				{
					bot.attributes.emplace_back("AlwaysFireWeapon");
					bot_pressure *= 1.5f;
					isAlwaysFireWeapon = true;
				}
			}
			if (rand_chance(0.02f))
			{
				bot.attributes.emplace_back("IgnoreFlag");
			}
			/*
			if (rand_chance(0.05f * chanceMult))
			{
				bot.attributes.emplace_back("BulletImmune");
				bot_pressure *= 2.0f;
			}
			if (rand_chance(0.05f * chanceMult))
			{
				bot.attributes.emplace_back("BlastImmune");
				bot_pressure *= 2.0f;
			}
			if (rand_chance(0.05f * chanceMult))
			{
				bot.attributes.emplace_back("FireImmune");
				bot_pressure *= 2.0f;
			}
			*/
			/*
			if (rand_chance(0.1f * chanceMult))
			{
				bot.attributes.emplace_back("Parachute");
			}
			*/

			if (item_class == player_class::medic)
			{
				if (bot.weapon_restrictions == "" || bot.weapon_restrictions == "SecondaryOnly")
				{
					/*
					if (rand_chance(0.2f * chanceMult))
					{
						bot.attributes.emplace_back("ProjectileShield");
						bot_pressure *= 3.0f;
					}
					*/
					if (secondary == "The Vaccinator")
					{
						if (rand_chance(0.5f * chanceMult))
						{
							const int type = rand_int(0, 3);
							switch (type)
							{
							case 0:
								bot.attributes.emplace_back("VaccinatorBullets");
								break;
							case 1:
								bot.attributes.emplace_back("VaccinatorBlast");
								break;
							case 2:
								bot.attributes.emplace_back("VaccinatorFire");
								break;
							}
							bot_pressure *= 1.1f;
						}
					}
				}
			}
			else if (item_class == player_class::demoman)
			{
				if (rand_chance(0.3f * chanceMult))
				{
					float charge_increase = rand_float(1.0f, 15.0f);

					bot_pressure *= ((charge_increase - 1.0f) * 0.03f) + 1.0f;
					if (rand_chance(0.01f * chanceMult))
					{
						charge_increase *= 10000.0f;
						bot_pressure *= 1.5f;
					}

					bot.character_attributes.emplace_back("charge time increased", charge_increase);
				}
			}
			else if (item_class == player_class::pyro)
			{
				if (bot.weapon_restrictions != "MeleeOnly" && bot.weapon_restrictions != "SecondaryOnly")
				{
					if (rand_chance(0.1f * chanceMult))
					{
						float r = rand_float(-10.0f, 10.0f);
						if (rand_chance(0.1f * chanceMult))
						{
							r *= 100.0f;
						}
						bot.character_attributes.emplace_back("airblast pushback scale", r);
					}
					if (rand_chance(0.1f * chanceMult))
					{
						float r = rand_float(-10.0f, 10.0f);
						if (rand_chance(0.1f * chanceMult))
						{
							r *= 100.0f;
						}
						bot.character_attributes.emplace_back("airblast vertical pushback scale", r);
					}
					if (rand_chance(0.1f * chanceMult))
					{
						float r = rand_float(0.1f, 10.0f);
						if (rand_chance(0.1f * chanceMult))
						{
							r *= 100.0f;
						}
						bot.character_attributes.emplace_back("deflection size multiplier", r);
						bot_pressure *= 1.3f;
					}
				}
			}

			if (bot.cl == player_class::engineer)
			{
				if (rand_chance(0.05f * chanceMult))
				{
					float r = rand_float(0.3f, 10.0f);
					if (rand_chance(0.01f * chanceMult))
					{
						r *= 0.01f;
					}
					bot.character_attributes.emplace_back("engy building health bonus", r);
					bot_pressure *= ((r - 1.0f) * 0.3f) + 1.0f;
				}
				if (rand_chance(0.05f * chanceMult))
				{
					float r = rand_float(0.3f, 5.0f);
					if (rand_chance(0.01f * chanceMult))
					{
						r *= 0.01f;
					}
					bot.character_attributes.emplace_back("engy sentry damage bonus", r);
					bot_pressure *= ((r - 1.0f) * 0.3f) + 1.0f;
				}
				if (rand_chance(0.05f * chanceMult))
				{
					float r = rand_float(0.1f, 3.0f);
					if (rand_chance(0.01f * chanceMult))
					{
						r *= 0.01f;
					}
					bot.character_attributes.emplace_back("engy sentry fire rate increased", r);
					bot_pressure /= ((r - 1.0f) * 0.3f) + 1.0f;
				}
				if (rand_chance(0.05f * chanceMult))
				{
					float r = rand_float(0.01f, 5.0f);
					if (rand_chance(0.01f * chanceMult))
					{
						r *= 0.01f;
					}
					bot.character_attributes.emplace_back("engy sentry radius increased", r);
					bot_pressure *= ((r - 1.0f) * 0.3f) + 1.0f;
				}
				if (rand_chance(0.05f * chanceMult))
				{
					float r = rand_float(0.01f, 5.0f);
					if (rand_chance(0.01f * chanceMult))
					{
						r *= 0.01f;
					}
					bot.character_attributes.emplace_back("engineer sentry build rate multiplier", r);
					bot_pressure /= ((r - 1.0f) * 0.2f) + 1.0f;
				}
				if (rand_chance(0.05f * chanceMult))
				{
					float r = rand_float(0.01f, 5.0f);
					if (rand_chance(0.01f * chanceMult))
					{
						r *= 0.01f;
					}
					bot.character_attributes.emplace_back("engineer teleporter build rate multiplier", r);
					bot_pressure /= ((r - 1.0f) * 0.2f) + 1.0f;
				}
			}

			if (rand_chance(0.08f * chanceMult))
			{
				bot.attributes.emplace_back("AutoJump");
				bot.auto_jump_min = rand_float(0.1f, 5.0f);
				if (rand_chance(0.5f))
				{
					bot.auto_jump_max = bot.auto_jump_min;
				}
				else
				{
					bot.auto_jump_max = bot.auto_jump_min + rand_float(0.1f, 5.0f);
				}
				bot_pressure *= 1.2f;

				if (rand_chance(0.5f))
				{
					float increased_jump_height = rand_float(0.1f, 15.0f);
					bot.character_attributes.emplace_back("increased jump height", increased_jump_height);
					bot.character_attributes.emplace_back("cancel falling damage", 1);
					if (increased_jump_height > 1.0f)
					{
						bot_pressure *= 1.2f;

						if (rand_chance(0.5f))
						{
							bot.items.emplace_back("The B.A.S.E. Jumper");
							bot_pressure *= 1.5f;
						}
					}
				}

				if (rand_chance(0.5f))
				{
					bot.character_attributes.emplace_back("bot custom jump particle", 1);
				}

				if (item_class == player_class::demoman)
				{
					if (rand_chance(0.2f * chanceMult))
					{
						bot.attributes.emplace_back("AirChargeOnly");
						bot_pressure *= 0.9f;
					}
				}
			}
			if (
				//!isGiant &&
				rand_chance(0.15f * chanceMult))
			{
				bot.scale *= rand_float(0.3f, 1.6f);
				bot_pressure /= ((bot.scale - 1.0f) * 0.3f) + 1.0f;
			}

			if (rand_chance(0.1f * chanceMult))
			{
				bot.max_vision_range = 30000.0f;
				if (bot.weapon_restrictions != "MeleeOnly")
				{
					bot_pressure *= 2.0f;
				}
			}
			if (rand_chance(0.1f * chanceMult))
			{
				float fire_rate_bonus = rand_float(0.1f, 2.0f);
				bot.character_attributes.emplace_back("fire rate bonus", fire_rate_bonus);
				bot.character_attributes.emplace_back("clip size bonus", 100000);
				bot_pressure /= ((fire_rate_bonus - 1.0f) * 0.3f) + 1.0f;
			}
			else if (rand_chance(0.1f * chanceMult))
			{
				if (rand_chance(0.4f))
				{
					float change = rand_float(0.1f, 2.0f);
					if (rand_chance(0.01f))
					{
						change *= 3.0f;
					}
					bot.character_attributes.emplace_back("faster reload rate", change);
					bot_pressure /= ((change - 1.0f) * 0.3f) + 1.0f;
				}
				else
				{
					bot.character_attributes.emplace_back("faster reload rate", -1);
					bot_pressure *= 1.4f;
				}
			}
			if (rand_chance(0.1f * chanceMult))
			{
				float damage_bonus_mod = rand_float(0.1f, 3.0f);
				damage_bonus *= damage_bonus_mod;
				/*
				if (rand_chance(0.01f))
				{
					damage_bonus *= 10.0f;
				}
				*/
			}
			if (rand_chance(0.1f * chanceMult) && secondary != "Bonk! Atomic Punch" && secondary != "Festive Bonk 2014")
			{
				const float change = rand_float(0.01f, 2.0f);
				bot.character_attributes.emplace_back("effect bar recharge rate increased", change);
				if (change < 1.0f)
				{
					bot_pressure /= ((change - 1.0f) * 0.3f) + 1.0f;
				}
			}
			//if (bot.weapon_restrictions != "MeleeOnly")
			//{
			if (rand_chance(0.1f * chanceMult))
			{
				const float change = rand_float(0.01f, 10.0f);
				bot.character_attributes.emplace_back("projectile speed increased", change);
				bot_pressure *= ((change - 1.0f) * 0.2f) + 1.0f;
			}
			if (rand_chance(0.1f * chanceMult))
			{
				int change = 3;
				while (rand_chance(0.5f) && change < 360)
				{
					change *= 3;
				}
				bot.character_attributes.emplace_back("projectile spread angle penalty", change);
			}
			if (rand_chance(0.05f * chanceMult))
			{
				int change = 3;
				bot_pressure *= 1.05f;
				while (rand_chance(0.5f) && change < 360)
				{
					change *= 3;
					bot_pressure *= 1.05f;
				}
				bot.character_attributes.emplace_back("weapon spread bonus", change);
			}
			//}
			if (rand_chance(0.03f * chanceMult))
			{
				if (rand_chance(0.5f))
				{
					bot.character_attributes.emplace_back("damage causes airblast", 1);
				}
				else
				{
					float look_velocity = rand_float(-10.0f, 10.0f);
					bot.character_attributes.emplace_back("apply_look_velocity_on_damage", look_velocity);
				}
				bot_pressure *= 2.5f;
			}
			if (rand_chance(0.05f * chanceMult))
			{
				float head_size = 0.001f;
				while (rand_chance(0.95f) && head_size < 10.0f)
				{
					head_size += 0.1f;
				}
				if (rand_chance(0.2f))
				{
					head_size *= -1.0f;
				}
				bot.character_attributes.emplace_back("head scale", head_size);
			}
			if (rand_chance(0.2f * chanceMult))
			{
				int proj_type = rand_int(1, 20);

				// Fix invalid values.
				switch (proj_type)
				{
				case 7:
					proj_type = 6; // Flare
					break;

				case 9:
				case 10:
				case 15:
				case 16:
					proj_type = 2; // Rocket
					break;
				}

				bot.character_attributes.emplace_back("override projectile type", proj_type);

				if (proj_type == 2 && item_class != player_class::soldier)
				{
					bot_pressure *= 1.5f;
				}
			}
			// The TeleportToHint attribute requires the other bots to have progressed a certain distance before this bot spawns.
			// If this wavespawn is not marked as support, this can lead to potentially unwinnable waves due to this bot never spawning in some conditions.
			/*
			if (bot.cl == player_class::engineer && rand_chance(0.2f))
			{
				bot.attributes.emplace_back("TeleportToHint");
				bot_pressure *= 2.0f;
			}
			*/
			if (rand_chance(0.05f * chanceMult))
			{
				bot.character_attributes.emplace_back("bleeding duration", 5.0f);
				bot_pressure *= 2.0f;
			}
			if (rand_chance(0.04f * chanceMult))
			{
				bot.character_attributes.emplace_back("Set DamageType Ignite", 1);
				// Add some cool fire particles.
				bot.character_attributes.emplace_back("attach particle effect static", 13);
				bot_pressure *= 2.0f;
				if (rand_chance(0.1f * chanceMult))
				{
					// Burn pretty much forever.
					bot.character_attributes.emplace_back("weapon burn time increased", 1000.0f);
					bot_pressure *= 1.3f;
				}
				if (rand_chance(0.5f))
				{
					const float r = rand_float(0.01f, 4.0f);
					bot.character_attributes.emplace_back("weapon burn dmg increased", r);
					bot_pressure *= ((r - 1.0f) * 0.3f) + 1.0f;
					/*
					if (r > 1.0f)
					{
						bot_pressure *= r;
					}
					else
					{
						bot_pressure *= 0.7f;
					}
					*/
				}
			}
			if (rand_chance(0.05f * chanceMult))
			{
				if (rand_chance(0.5f))
				{
					float slow_chance = rand_float(0.1f, 1.0f);
					bot.character_attributes.emplace_back("slow enemy on hit", slow_chance);
					bot_pressure *= 1.0f + slow_chance;
				}
				else
				{
					bot.character_attributes.emplace_back("slow enemy on hit major", 1);
					bot_pressure *= 2.0f;
				}
			}
			if (rand_chance(0.05f * chanceMult))
			{
				bot.character_attributes.emplace_back("no self blast dmg", 1);
			}
			if (rand_chance(0.01f))
			{
				bot.character_attributes.emplace_back("melee bounds multiplier", 360.0f);
				bot.character_attributes.emplace_back("melee range multiplier", 30000.0f);
				bot.character_attributes.emplace_back("Blast radius increased", 30000.0f);
				damage_bonus *= 0.01f;
				// Compensate for the massively decreased damage bonus.
				bot_pressure *= 50.0f;
			}
			if (rand_chance(0.02f))
			{
				bot.character_attributes.emplace_back("use large smoke explosion", 1);
				bot_pressure *= 1.2f;
			}
			else if (rand_chance(0.05f * chanceMult))
			{
				float rad = rand_float(0.1f, 5.0f);
				bot.character_attributes.emplace_back("Blast radius increased", rad);
				bot_pressure *= ((rad - 1.0f) * 0.3f) + 1.0f;
				if (rad > 1.0f && rand_chance(0.5f))
				{
					bot.character_attributes.emplace_back("use large smoke explosion", 1);
				}
			}
			if (rand_chance(0.1f * chanceMult))
			{
				float rad = rand_float(0.1f, 5.0f);
				bot.character_attributes.emplace_back("bullets per shot bonus", rad);
				bot_pressure *= ((rad - 1.0f) * 0.3f) + 1.0f;
			}
			if (item_class == player_class::soldier || item_class == player_class::sniper || item_class == player_class::pyro)
			{
				if (rand_chance(0.1f))
				{
					const float rad = rand_float(0.1f, 20.0f);
					bot.character_attributes.emplace_back("increase buff duration", rad);
					bot_pressure *= ((rad - 1.0f) * 0.3f) + 1.0f;
				}
			}
			if (rand_chance(0.03f))
			{
				bot.character_attributes.emplace_back("hit self on miss", 1);
			}
			if (rand_chance(0.02f * chanceMult))
			{
				float r = rand_float(-10000.0f, 10000.0f);
				bot.character_attributes.emplace_back("apply z velocity on damage", r);
				bot_pressure *= 2.0f;
			}
			/*
			if (rand_chance(0.05f * chanceMult))
			{
				bot.character_attributes.emplace_back("projectile penetration", 1);
				bot_pressure *= 1.1f;
			}
			*/
			if (rand_chance(0.01f))
			{
				bot.character_attributes.emplace_back("attach particle effect static", rand_int(1, 48));
				bot.health *= 2;
			}

			// Set a random skill level for the bot.
			std::vector<std::string> skills({ "Easy", "Normal", "Hard", "Expert" });
			int skill_index = rand_int(0, skills.size());
			bot.skill = skills.at(skill_index);
			float skill_pressure = (skill_index * 0.4f) + 1.0f;
			bot_pressure *= skill_pressure;

			bot.character_attributes.emplace_back("damage bonus", damage_bonus);
			if (damage_bonus > 0.0f)
			{
				/*
				if (damage_bonus < 1.0f)
				{
					bot_pressure *= ((damage_bonus - 1.0f) * 0.3f) + 1.0f;
				}
				else
				{
					bot_pressure *= damage_bonus;
				}
				*/
				bot_pressure *= damage_bonus * 2.0f;
			}

			std::cout << "Pre-TotalCount loop bot health: " << bot.health << std::endl;

			if (bot.health <= 0)
			{
				throw std::exception("wave_generator::generate_mission exception: Non-positive bot health!");
			}

			std::cout << "Pre-TotalCount loop bot pressure (without health): " << bot_pressure << std::endl;

			if (bot_pressure < 0.0f)
			{
				throw std::exception("wave_generator::generate_mission exception: Negative bot pressure!");
			}

			// Calculate WaveSpawn data for the TFBot.
			// The following loop makes sure the TFBot doesn't have too much health to handle.

			int max_count = 0;
			float effective_pressure;
			float wait_between_spawns;
			// How long it should take to kill the theoretical bot.
			float time_to_kill;
			//float effective_time_to_kill;

			std::cout << "Entering TotalCount calculation loop..." << std::endl;

			// Cache the recipricol of the pressure decay rate.
			const float recip_pressure_decay_rate = 1 / pressure_decay_rate;

			/*
			// Will be 0 if there's no pressure.
			float pressure_compensation = pressure * recip_pressure_decay_rate;
			if (pressure_compensation < 1.0f)
			{
				pressure_compensation = 1.0f;
			}
			else
			{
				pressure_compensation = ((pressure_compensation - 1.0f) * 0.2f) + 1.0f;
				std::cout << "Pressure is nonzero (" << pressure << "). Pressure compensation: " << pressure_compensation << '.' << std::endl;
				std::getchar();
			}
			*/

			while (max_count == 0)
			{
				effective_pressure = bot_pressure * bot.health;
				time_to_kill = effective_pressure * recip_pressure_decay_rate;
				wait_between_spawns = time_to_kill * rand_float(1.0f, 5.0f); // * pressure_compensation;
				max_count = static_cast<int>(floor((max_time - t) / wait_between_spawns));

				std::cout << "Bot can theoretically be killed within " << time_to_kill << " seconds." << std::endl;
				//std::getchar();

				//effective_time_to_kill = effective_pressure / effective_pressure_decay_rate;

				//bool has_pressure_issue = (pressure_compensation > 0.0f && bot.health > pressure_decay_rate * 100.0f / pressure_compensation);

				// If the max count is too low, it means the bot may be too strong.
				if (max_count == 0 && bot.health > 25)
				{
					max_count = 0;
					bot.health = static_cast<int>(bot.health * 0.9f);
					/*
					// If the wave isn't almost over, keep dwindling the bot's health down.
					if (max_time - t > 20)
					{
						bot.health *= 0.9f;
					}
					// If the wave is almost over...
					else
					{
						// Just let the bot live at its full strength if it's strong, but not TOO strong.
						max_count = floor(max_time / wait_between_spawns);
						if (max_count != 0)
						{
							max_count = 1;
						}
					}
					*/
				}
				else if (max_count > 100)
				{
					if (rand_chance(0.9f))
					{
						if (isGiant)
						{
							bot.health *= 2;
						}
						else if (!permaSmall)
						{
							make_bot_into_giant(bot, isGiant, move_speed_bonus, chanceMult, bot_pressure, isBoss, isAlwaysCrit);
						}
						else
						{
							bot.health *= 2;
						}
						max_count = 0;
					}
				}
				else if (isBoss || bot.health <= 25)
				{
					max_count = 1;
				}
			}

			//max_count = ceil(static_cast<float>(max_count) * 0.7f);

			std::cout << "TotalCount calculation complete." << std::endl;
			std::cout << "Post-TotalCount loop bot health: " << bot.health << std::endl;
			std::cout << "The bot's effective pressure (with health): " << effective_pressure << std::endl;
			std::cout << "TotalCount: " << max_count << std::endl;
			std::cout << "WaitBetweenSpawns: " << wait_between_spawns << std::endl;

			class_icons.emplace(bot.class_icon);

			std::cout << "Total class icons so far: " << class_icons.size() << '.' << std::endl;

			bot.character_attributes.emplace_back("move speed bonus", move_speed_bonus);

			wavespawn ws;
			std::stringstream wsname;
			wsname << "\"wave" << current_wave << '_' << wavespawns.size() + 1 << '\"';
			ws.name = wsname.str();
			ws.total_count = rand_int(1, max_count + 1);
			ws.max_active = std::min(22, ws.total_count);
			ws.wait_before_starting = static_cast<float>(t);
			ws.wait_between_spawns = wait_between_spawns;
			ws.bot = bot;
			ws.effective_pressure = effective_pressure;
			ws.time_to_kill = time_to_kill;
			ws.time_until_next_spawn = ws.wait_between_spawns;
			ws.spawns_remaining = ws.total_count;
			ws.type_of_spawned = wavespawn::type::tfbot;
			wavespawns.emplace_back(ws);

			pressure += effective_pressure;

			std::cout << "Added bot to wavespawn." << std::endl;

			/*
			// Recalculate the effective pressure decay rate.
			calculate_effective_pressure_decay_rate(pressure_decay_rate, effective_pressure_decay_rate, wavespawns, t);
		}
		*/

			// Time to do any final work before the next loop iteration (if there is one).

			// An empty second is a second that occurs without a single new WaveSpawn.
			// To prevent boredom, this amount of time is capped.
			int empty_seconds = 0;
			while (pressure > 0
				//&& empty_seconds < 3
				)
			{
				// Increment time.
				++t;
				++empty_seconds;
				// Iterate through the wavespawns to update the pressure.
				for (wavespawn& ws : wavespawns)
				{
					ws.time_until_next_spawn -= 1;
					while (ws.spawns_remaining != 0 && ws.time_until_next_spawn <= 0.0f)
					{
						pressure += ws.effective_pressure;
						ws.time_until_next_spawn += ws.wait_between_spawns;
						ws.spawns_remaining -= 1;
						
						// Since something just spawned, reset the empty seconds.
						empty_seconds = 0;
						//std::cout << "Empty seconds reset." << std::endl;
					}
				}
				// Since time has passed, reduce the pressure.
				pressure -= pressure_decay_rate;
			}

			//++t;

			std::cout << "t = " << t << std::endl;
		}

		std::cout << "Wave generation complete. Writing to popfile..." << std::endl;

		current_currency += currency_per_wave;
		int currency_per_wavespawn = currency_per_wave / wavespawns.size();

		// Write the WaveSpawns.
		for (const wavespawn& ws : wavespawns)
		{
			block_start("WaveSpawn");
			write("Name", ws.name);
			write("TotalCount", ws.total_count);
			write("WaitBeforeStarting", ws.wait_before_starting);
			write("WaitBetweenSpawns", ws.wait_between_spawns);
			write("TotalCurrency", currency_per_wavespawn);
			if (ws.type_of_spawned == wavespawn::type::tfbot)
			{
				write("SpawnCount", ws.spawn_count);
				write("MaxActive", ws.max_active);
				write("Where", "spawnbot");
				write_blank();
				block_start("TFBot");
				write("Class", player_class_to_string(ws.bot.cl));
				write("Name \"" + ws.bot.name + '\"');
				write("ClassIcon", ws.bot.class_icon);
				write("Health", ws.bot.health);
				if (ws.bot.scale > 0.0f)
				{
					write("Scale", ws.bot.scale);
				}
				write("Skill", ws.bot.skill);

				if (ws.bot.weapon_restrictions != "")
				{
					write("WeaponRestrictions", ws.bot.weapon_restrictions);
				}
				if (ws.bot.max_vision_range > 0.0f)
				{
					write("MaxVisionRange", ws.bot.max_vision_range);
				}
				if (ws.bot.cl == player_class::engineer)
				{
					write("TeleportWhere", "spawnbot");
				}

				// Write all Attributes.
				int attributes_count = ws.bot.attributes.size();
				for (int i = 0; i < attributes_count; ++i)
				{
					write("Attributes", ws.bot.attributes.at(i));
				}

				if (ws.bot.auto_jump_min != 0.0f)
				{
					write("AutoJumpMin", ws.bot.auto_jump_min);
					write("AutoJumpMax", ws.bot.auto_jump_max);
				}
				
				// Write Items.
				int items_count = ws.bot.items.size();
				for (int i = 0; i < items_count; ++i)
				{
					write("Item", '\"' + ws.bot.items.at(i) + '\"');
				}

				// Write CharacterAttributes.
				int character_attributes_count = ws.bot.character_attributes.size();
				if (character_attributes_count != 0)
				{
					block_start("CharacterAttributes");
					for (int i = 0; i < character_attributes_count; ++i)
					{
						write('\"' + ws.bot.character_attributes.at(i).first + '\"', ws.bot.character_attributes.at(i).second);
					}
					block_end(); // CharacterAttributes
				}

				block_end(); // TFBot
			}
			else if (ws.type_of_spawned == wavespawn::type::tank)
			{
				write_blank();
				block_start("FirstSpawnOutput");
				write("Target", "boss_spawn_relay");
				write("Action", "Trigger");
				block_end(); // FirstSpawnOutput
				write_blank();
				block_start("Tank");
				write("Health", ws.tnk.health);
				write("Speed", ws.tnk.speed);
				write("Name", "\"tankboss\"");
				write("StartingPathTrackNode", "\"boss_path_a1\"");
				block_start("OnKilledOutput");
				write("Target", "boss_dead_relay");
				write("Action", "Trigger");
				block_end(); // OnKilledOutput
				block_start("OnBombDroppedOutput");
				write("Target", "boss_deploy_relay");
				write("Action", "Trigger");
				block_end(); // OnBombDroppedOutput
				block_end(); // Tank
			}

			block_end(); // WaveSpawn
		}
		block_end(); // Wave
	}

	block_end(); // WaveSchedule
	popfile.close();

	std::cout << "Write complete." << std::endl;
}

void wave_generator::write_indents()
{
	for (int i = 0; i < indent; ++i)
	{
		popfile << '\t';
	}
}

void wave_generator::write(const std::string& str)
{
	write_indents();
	popfile << str << '\n';
}

void wave_generator::write(const std::string& str, int number)
{
	write_indents();
	popfile << str << ' ' << number << '\n';
}

void wave_generator::write(const std::string& str, float number)
{
	write_indents();
	popfile << str << ' ' << number << '\n';
}

void wave_generator::write(const std::string& str1, const std::string& str2)
{
	write_indents();
	popfile << str1 << ' ' << str2 << '\n';
}

void wave_generator::write_blank()
{
	popfile << '\n';
}

void wave_generator::block_start(const std::string& str)
{
	write(str);
	write("{");
	++indent;
}

void wave_generator::block_end()
{
	--indent;
	write("}");
}

void wave_generator::make_bot_into_giant(tfbot& bot, bool& isGiant, float& move_speed_bonus, float& chanceMult, float& bot_pressure, bool& isBoss, bool& isAlwaysCrit)
{
	bot.make_giant();
	isGiant = true;
	bot.scale = -1.0f;
	// Being a giant multiplies the TFBot's health by 15.
	bot.health *= 15;
	// Add some giant-related attributes.
	bot.character_attributes.emplace_back("airblast vulnerability multiplier", rand_float(0.3f, 0.7f));
	bot.character_attributes.emplace_back("damage force reduction", rand_float(0.3f, 0.7f));
	// If the class isn't Scout, incur a move speed penalty...
	if (bot.cl != player_class::scout)
	{
		move_speed_bonus *= 0.5f;
		bot_pressure *= 0.5f;
	}

	// Modify the bot class icon.
	bot.class_icon += "_giant";
	switch (bot.cl)
	{
	case player_class::scout:
		if (bot.class_icon != "scout_bonk_giant" && move_speed_bonus > 1.0f)
		{
			bot.class_icon = "scout_giant_fast";
		}
		break;

	case player_class::soldier:
		if (isAlwaysCrit && bot.class_icon == "soldier_giant")
		{
			bot.class_icon = "soldier_crit";
		}
	}

	// A giant has a chance to be a BOSS!!!
	if (rand_chance(0.1f))
	{
		isBoss = true;
		bot.health *= 5;
		move_speed_bonus *= 0.5;
		bot_pressure *= 0.5;
		bot.attributes.emplace_back("UseBossHealthBar");
		chanceMult *= 4.0f;
		bot.scale = 1.9f;

		bot.character_attributes.emplace_back("attach particle effect static", rand_int(1, 48));

		// Now that you're a boss, choose a special class icon.
		switch (bot.cl)
		{
		case player_class::demoman:
			//if (bot.class_icon == "demo_giant")
			if (bot.weapon_restrictions == "PrimaryOnly")
			{
				bot.class_icon = "demo_bomber";
				bot.items.emplace_back("Prince Tavish's Crown");
			}
			else if (bot.class_icon == "demoknight_giant")
			{
				bot.class_icon = "demoknight_samurai";
			}
			break;

		case player_class::heavyweapons:
			if (bot.weapon_restrictions == "PrimaryOnly")
			{
				bot.class_icon = "heavy_chief";
				bot.items.emplace_back("War Head");
			}
			else if (bot.class_icon == "heavy_gru_giant")
			{
				bot.class_icon = "heavy_urgent";
			}
			break;

		case player_class::scout:
			if (bot.class_icon == "scout_stun_giant")
			{
				bot.class_icon = "scout_stun_giant_armored";
			}
			break;

		case player_class::soldier:
			if (bot.weapon_restrictions == "MeleeOnly")
			{
				bot.class_icon = "soldier_major_crits";
				bot.items.emplace_back("Full Metal Drill Hat");
			}
			else if (bot.weapon_restrictions == "SecondaryOnly")
			{
				bot.class_icon = "soldier_sergeant_crits";
				bot.items.emplace_back("Tyrant's Helm");
			}
			else
			{
				bot.class_icon = "soldier_barrage";
			}
			break;
		}
	}
}

void wave_generator::calculate_effective_pressure_decay_rate
(const float& pressure_decay_rate, float& effective_pressure_decay_rate, const std::vector<wavespawn>& wavespawns, const int& t)
{
	effective_pressure_decay_rate = pressure_decay_rate;

	std::cout << wavespawns.size() << " wavespawns generated thus far." << std::endl;

	for (const wavespawn& ws : wavespawns)
	{
		/*
		if (ws.spawns_remaining != 0
			//&& t >= ws.wait_before_starting
			)
		*/

		float time_of_last_spawn = ws.wait_before_starting + ws.wait_between_spawns * (ws.total_count - 1);
		float time_of_last_dead = time_of_last_spawn + ws.time_to_kill;

		if (t >= ws.wait_before_starting && t <= time_of_last_dead)
		{
			//std::cout << "Wavespawn is active!" << std::endl;

			float wavespawn_pressure_per_second = ws.effective_pressure / ws.wait_between_spawns;

			/*
			std::cout << "Wavespawn's effective pressure: " << ws.effective_pressure << std::endl;
			std::cout << "Wavespawn's wait between spawns: " << ws.wait_between_spawns << std::endl;
			std::cout << "Wavespawn's pressure per second: " << wavespawn_pressure_per_second << std::endl;
			*/

			effective_pressure_decay_rate -= wavespawn_pressure_per_second;
		}
	}

	std::cout << "Effective pressure decay rate: " << effective_pressure_decay_rate << std::endl;
}